<!DOCTYPE html>
<script src="./src/PathfindingHelper.js"></script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<title>demo</title>
<link href="style.css" rel="stylesheet">
<script src="https://unpkg.com/three@0.124.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.124.0/examples/js/libs/dat.gui.min.js"></script>
<script src="https://unpkg.com/three@0.124.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.124.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="./dist/three-pathfinding.umd.js"></script>
<body>

    <script>


        const Color = {
            GROUND: new THREE.Color( 0xe5e5ff ).convertGammaToLinear( 2.2 ).getHex(),
            NAVMESH: new THREE.Color( 0xe5e5ff ).convertGammaToLinear( 2.2 ).getHex(),
        };

        const ZONE = 'level';
        const SPEED = 20;
        const OFFSET = 0.2;

        THREE.Pathfinding = threePathfinding.Pathfinding;
        THREE.PathfindingHelper = threePathfinding.PathfindingHelper;

        let level, navmesh;
        let groupID, path;

        const playerPos = new THREE.Vector3( 5.2, 3, 5.2);
        const startPos = playerPos;
        const targetPos = new THREE.Vector3();

        const pathFinder = new THREE.Pathfinding();
        const helper = new THREE.PathfindingHelper();
        const mouse = new THREE.Clock();
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();

        const scene = new THREE.Scene();
        scene.add(helper);


        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(50, 50, 50);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        // renderer.shadowMap.enabled = true
        // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.damping = 0.2;

        const ambient = new THREE.AmbientLight(0x00001a);
        scene.add(ambient);

        const directionalLight = new THREE.PointLight(0xffeedd, 1);
        directionalLight.position.set(100, 100, 100);
        // directionalLight.castShadow = true;
        scene.add(directionalLight);


        //添加调试菜单
        let gui = new dat.GUI();
        let params = {
            灯光亮度: 1,

            重设位置: function (){
                helper.setPlayerPosition(new THREE.Vector3(5.2, 3, 5.2));
                helper.setTargetPosition(new THREE.Vector3(5.2, 3, 5.2));
                playerPos.copy(new THREE.Vector3(5.2, 3, 5.2));
                targetPos.copy(new THREE.Vector3(5.2, 3, 5.2));
                path = pathFinder.findPath(playerPos, targetPos,ZONE, groupID);
                helper.setPath(path);
            }

        }
        gui.add(params, '灯光亮度', 1, 2);
        gui.add(params, '重设位置');


        GLTFinit();
        render();



        function GLTFinit(){
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load('./demo/meshes/floor.glb', function (gltf){

                const levelMesh = gltf.scene.children[0];
                const meshMaterial = new THREE.MeshStandardMaterial({
                    color: Color.GROUND,
                    flatShading: true,
                    roughness: 1,
                    metalness: 0
                })
                level = new THREE.Mesh(levelMesh.geometry, meshMaterial);
                // level.castShadow = true;
                // level.receiveShadow = true;
                window.level = level;
                scene.add(levelMesh);
            }, null);

            gltfLoader.load('./demo/meshes/floor.nav.glb', function (gltf) {
                const navMesh = gltf.scene.children[0];

                const zone = THREE.Pathfinding.createZone(navMesh.geometry);

                pathFinder.setZoneData(ZONE, zone);

                // const navWireframe = new THREE.Mesh(navMesh.geometry, new THREE.MeshBasicMaterial({
                //     color: 0xffffff,
                //     wireframe: true
                // }));
                // navWireframe.position.y = OFFSET / 2;
                // scene.add(navWireframe);

                navmesh = new THREE.Mesh(navMesh.geometry, new THREE.MeshBasicMaterial({
                    color: Color.NAVMESH,
                    opacity: 0.75,
                    transparent: true
                }));

                //scene.add(navmesh);

                groupID = pathFinder.getGroup(ZONE, playerPos);

            }, null);

            helper.setPlayerPosition(new THREE.Vector3(5.2, 3, 5.2));
            helper.setTargetPosition(new THREE.Vector3(5.2, 3, 5.2));
            document.addEventListener('click', onDocumentMouseUp, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onDocumentMouseUp(event){
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            camera.updateMatrixWorld();

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(navmesh);
            if(!intersects.length) return;

            targetPos.copy(intersects[0].point);

            helper.reset();
            helper.setPlayerPosition(playerPos);

            if (event.metaKey || event.ctrlKey || event.button === 2) {

                path = null;
                groupID = pathFinder.getGroup(ZONE, targetPos, true);
                const closestNode = pathFinder.getClosestNode( playerPos, ZONE, groupID, true );

                helper.setPlayerPosition( playerPos.copy( targetPos ) )
                if ( closestNode ) helper.setNodePosition( closestNode.centroid );

                return;

            }

            const targetGroupID = pathFinder.getGroup(ZONE, targetPos);
            const closestTargetNode = pathFinder.getClosestNode(targetPos, ZONE, targetGroupID,true)


            helper.setTargetPosition(targetPos);
            if(closestTargetNode) helper.setNodePosition(closestTargetNode);

            path = pathFinder.findPath(playerPos, targetPos,ZONE, groupID);

            if(path && path.length){
                helper.setPath(path);
            }
            else{
                const closestPlayerNode = pathFinder.getClosestNode( playerPosition, ZONE, groupID );
                const clamped = new THREE.Vector3();

                // TODO(donmccurdy): Don't clone targetPosition, fix the bug.
                pathFinder.clampStep(
                    playerPos, targetPos.clone(), closestPlayerNode, ZONE, groupID, clamped );

                helper.setStepPosition( clamped );
            }
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function render(){
            directionalLight.intensity = params.灯光亮度;
            requestAnimationFrame(render);
            tick(clock.getDelta());
            renderer.render(scene, camera);
        }
        function tick ( dt ) {
            if ( !level || !(path||[]).length ) return

            let targetPosition = path[ 0 ];
            const velocity = targetPosition.clone().sub( playerPos );

            if (velocity.lengthSq() > 0.05 * 0.05) {
                velocity.normalize();
                // Move player to target
                playerPos.add( velocity.multiplyScalar( dt * SPEED ) );
                helper.setPlayerPosition( playerPos );
            } else {
                // Remove node from the path we calculated
                path.shift();
            }
        }


    </script>

</body>
</html>