{"version":3,"file":"three-pathfinding.module.js","sources":["../src/Pathfinding.js","../src/Utils.js","../src/BinaryHeap.js","../src/AStar.js","../src/Builder.js","../src/Channel.js","../src/PathfindingHelper.js"],"sourcesContent":["import {\n\tVector3,\n\tPlane,\n\tTriangle,\n} from 'three';\n\nimport { Utils } from './Utils';\nimport { AStar } from './AStar';\nimport { Builder } from './Builder';\nimport { Channel } from './Channel';\n\n/**\n * Defines an instance of the pathfinding module, with one or more zones.\n */\nclass Pathfinding {\n\tconstructor () {\n\t\tthis.zones = {};\n\t}\n\n\t/**\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\n\t * @param  {BufferGeometry} geometry\n\t * @param  {number} tolerance Vertex welding tolerance.\n\t * @return {Zone}\n\t */\n\tstatic createZone (geometry, tolerance = 1e-4) {\n\t\treturn Builder.buildZone(geometry, tolerance);\n\t}\n\n\t/**\n\t * Sets data for the given zone.\n\t * @param {string} zoneID\n\t * @param {Zone} zone\n\t */\n\tsetZoneData (zoneID, zone) {\n\t\tthis.zones[zoneID] = zone;\n\t}\n\n\t/**\n\t * Returns a random node within a given range of a given position.\n\t * @param  {string} zoneID\n\t * @param  {number} groupID\n\t * @param  {Vector3} nearPosition\n\t * @param  {number} nearRange\n\t * @return {Node}\n\t */\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\n\n\t\tif (!this.zones[zoneID]) return new Vector3();\n\n\t\tnearPosition = nearPosition || null;\n\t\tnearRange = nearRange || 0;\n\n\t\tconst candidates = [];\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\n\n\t\tpolygons.forEach((p) => {\n\t\t\tif (nearPosition && nearRange) {\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\n\t\t\t\t\tcandidates.push(p.centroid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidates.push(p.centroid);\n\t\t\t}\n\t\t});\n\n\t\treturn Utils.sample(candidates) || new Vector3();\n\t}\n\n\t/**\n\t * Returns the closest node to the target position.\n\t * @param  {Vector3} position\n\t * @param  {string}  zoneID\n\t * @param  {number}  groupID\n\t * @param  {boolean} checkPolygon\n\t * @return {Node}\n\t */\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tlet closestNode = null;\n\t\tlet closestDistance = Infinity;\n\n\t\tnodes.forEach((node) => {\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\n\t\t\tif (distance < closestDistance\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\n\t\t\t\tclosestNode = node;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closestNode;\n\t}\n\n\t/**\n\t * Returns a path between given start and end points. If a complete path\n\t * cannot be found, will return the nearest endpoint available.\n\t *\n\t * @param  {Vector3} startPosition Start position.\n\t * @param  {Vector3} targetPosition Destination.\n\t * @param  {string} zoneID ID of current zone.\n\t * @param  {number} groupID Current group ID.\n\t * @return {Array<Vector3>} Array of points defining the path.\n\t */\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\n\t\tconst closestNode = this.getClosestNode(startPosition, zoneID, groupID, true);\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\n\n\t\t// If we can't find any node, just go straight to the target\n\t\tif (!closestNode || !farthestNode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\n\n\t\tconst getPortalFromTo = function (a, b) {\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\n\t\t\t\tif (a.neighbours[i] === b.id) {\n\t\t\t\t\treturn a.portals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We have the corridor, now pull the rope.\n\t\tconst channel = new Channel();\n\t\tchannel.push(startPosition);\n\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\tconst polygon = paths[i];\n\t\t\tconst nextPolygon = paths[i + 1];\n\n\t\t\tif (nextPolygon) {\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\n\t\t\t\tchannel.push(\n\t\t\t\t\tvertices[portals[0]],\n\t\t\t\t\tvertices[portals[1]]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchannel.push(targetPosition);\n\t\tchannel.stringPull();\n\n\t\t// Return the path, omitting first position (which is already known).\n\t\tconst path = channel.path.map((c) => new Vector3(c.x, c.y, c.z));\n\t\tpath.shift();\n\t\treturn path;\n\t}\n}\n\n/**\n * Returns closest node group ID for given position.\n * @param  {string} zoneID\n * @param  {Vector3} position\n * @return {number}\n */\nPathfinding.prototype.getGroup = (function() {\n\tconst plane = new Plane();\n\treturn function (zoneID, position, checkPolygon = false) {\n\t\tif (!this.zones[zoneID]) return null;\n\n\t\tlet closestNodeGroup = null;\n\t\tlet distance = Math.pow(50, 2);\n\t\tconst zone = this.zones[zoneID];\n\n\t\tfor (let i = 0; i < zone.groups.length; i++) {\n\t\t\tconst group = zone.groups[i];\n\t\t\tfor (const node of group) {\n\t\t\t\tif (checkPolygon) {\n\t\t\t\t\tplane.setFromCoplanarPoints(\n\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\n\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\n\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\n\t\t\t\t\t);\n\t\t\t\t\tif (Math.abs(plane.distanceToPoint(position)) < 0.01) {\n\t\t\t\t\t\tconst poly = [\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\n\t\t\t\t\t\t];\n\t\t\t\t\t\tif(Utils.isPointInPoly(poly, position)) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\n\t\t\t\tif (measuredDistance < distance) {\n\t\t\t\t\tclosestNodeGroup = i;\n\t\t\t\t\tdistance = measuredDistance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn closestNodeGroup;\n\t};\n}());\n\n/**\n * Clamps a step along the navmesh, given start and desired endpoint. May be\n * used to constrain first-person / WASD controls.\n *\n * @param  {Vector3} start\n * @param  {Vector3} end Desired endpoint.\n * @param  {Node} node\n * @param  {string} zoneID\n * @param  {number} groupID\n * @param  {Vector3} endTarget Updated endpoint.\n * @return {Node} Updated node.\n */\nPathfinding.prototype.clampStep = (function () {\n\tconst point = new Vector3();\n\tconst plane = new Plane();\n\tconst triangle = new Triangle();\n\n\tconst endPoint = new Vector3();\n\n\tlet closestNode;\n\tlet closestPoint = new Vector3();\n\tlet closestDistance;\n\n\treturn function (startRef, endRef, node, zoneID, groupID, endTarget) {\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\n\t\tconst nodeQueue = [node];\n\t\tconst nodeDepth = {};\n\t\tnodeDepth[node.id] = 0;\n\n\t\tclosestNode = undefined;\n\t\tclosestPoint.set(0, 0, 0);\n\t\tclosestDistance = Infinity;\n\n\t\t// Project the step along the current node.\n\t\tplane.setFromCoplanarPoints(\n\t\t\tvertices[node.vertexIds[0]],\n\t\t\tvertices[node.vertexIds[1]],\n\t\t\tvertices[node.vertexIds[2]]\n\t\t);\n\t\tplane.projectPoint(endRef, point);\n\t\tendPoint.copy(point);\n\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\n\n\t\t\ttriangle.set(\n\t\t\t\tvertices[currentNode.vertexIds[0]],\n\t\t\t\tvertices[currentNode.vertexIds[1]],\n\t\t\t\tvertices[currentNode.vertexIds[2]]\n\t\t\t);\n\n\t\t\ttriangle.closestPointToPoint(endPoint, point);\n\n\t\t\tif (point.distanceToSquared(endPoint) < closestDistance) {\n\t\t\t\tclosestNode = currentNode;\n\t\t\t\tclosestPoint.copy(point);\n\t\t\t\tclosestDistance = point.distanceToSquared(endPoint);\n\t\t\t}\n\n\t\t\tconst depth = nodeDepth[currentNode.id];\n\t\t\tif (depth > 2) continue;\n\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\n\n\t\t\t\tnodeQueue.push(neighbour);\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\n\t\t\t}\n\t\t}\n\n\t\tendTarget.copy(closestPoint);\n\t\treturn closestNode;\n\t};\n}());\n\n/**\n * Defines a zone of interconnected groups on a navigation mesh.\n *\n * @type {Object}\n * @property {Array<Group>} groups\n * @property {Array<Vector3>} vertices\n */\nconst Zone = {}; // jshint ignore:line\n\n/**\n * Defines a group within a navigation mesh.\n *\n * @type {Object}\n */\nconst Group = {}; // jshint ignore:line\n\n/**\n * Defines a node (or polygon) within a group.\n *\n * @type {Object}\n * @property {number} id\n * @property {Array<number>} neighbours IDs of neighboring nodes.\n * @property {Array<number>} vertexIds\n * @property {Vector3} centroid\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\n * @property {boolean} closed\n * @property {number} cost\n */\nconst Node = {}; // jshint ignore:line\n\nexport { Pathfinding };\n","import { BufferAttribute, BufferGeometry } from 'three';\n\nclass Utils {\n\n  static roundNumber (value, decimals) {\n    const factor = Math.pow(10, decimals);\n    return Math.round(value * factor) / factor;\n  }\n\n  static sample (list) {\n    return list[Math.floor(Math.random() * list.length)];\n  }\n\n  static distanceToSquared (a, b) {\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    var dz = a.z - b.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  }\n\n  //+ Jonas Raoni Soares Silva\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static isPointInPoly (poly, pt) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\n    return c;\n  }\n\n  static isVectorInPolygon (vector, polygon, vertices) {\n\n    // reference point will be the centroid of the polygon\n    // We need to rotate the vector as well as all the points which the polygon uses\n\n    var lowestPoint = 100000;\n    var highestPoint = -100000;\n\n    var polygonVertices = [];\n\n    polygon.vertexIds.forEach((vId) => {\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\n      polygonVertices.push(vertices[vId]);\n    });\n\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\n      this.isPointInPoly(polygonVertices, vector)) {\n      return true;\n    }\n    return false;\n  }\n\n  static triarea2 (a, b, c) {\n    var ax = b.x - a.x;\n    var az = b.z - a.z;\n    var bx = c.x - a.x;\n    var bz = c.z - a.z;\n    return bx * az - ax * bz;\n  }\n\n  static vequal (a, b) {\n    return this.distanceToSquared(a, b) < 0.00001;\n  }\n\n  /**\n   * Modified version of BufferGeometryUtils.mergeVertices, ignoring vertex\n   * attributes other than position.\n   *\n   * @param {THREE.BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {THREE.BufferGeometry>}\n   */\n  static mergeVertices (geometry, tolerance = 1e-4) {\n\n    tolerance = Math.max( tolerance, Number.EPSILON );\n\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute( 'position' );\n    var vertexCount = indices ? indices.count : positions.count;\n\n    // Next value for triangle indices.\n    var nextIndex = 0;\n\n    var newIndices = [];\n    var newPositions = [];\n\n    // Convert the error tolerance to an amount of decimal places to truncate to.\n    var decimalShift = Math.log10( 1 / tolerance );\n    var shiftMultiplier = Math.pow( 10, decimalShift );\n\n    for ( var i = 0; i < vertexCount; i ++ ) {\n\n      var index = indices ? indices.getX( i ) : i;\n\n      // Generate a hash for the vertex attributes at the current index 'i'.\n      var hash = '';\n\n      // Double tilde truncates the decimal value.\n      hash += `${ ~ ~ ( positions.getX( index ) * shiftMultiplier ) },`;\n      hash += `${ ~ ~ ( positions.getY( index ) * shiftMultiplier ) },`;\n      hash += `${ ~ ~ ( positions.getZ( index ) * shiftMultiplier ) },`;\n\n      // Add another reference to the vertex if it's already\n      // used by another index.\n      if ( hash in hashToIndex ) {\n\n        newIndices.push( hashToIndex[ hash ] );\n\n      } else {\n\n        newPositions.push( positions.getX( index ) );\n        newPositions.push( positions.getY( index ) );\n        newPositions.push( positions.getZ( index ) );\n\n        hashToIndex[ hash ] = nextIndex;\n        newIndices.push( nextIndex );\n        nextIndex ++;\n\n      }\n\n    }\n\n    // Construct merged BufferGeometry.\n\n    const positionAttribute = new BufferAttribute(\n      new Float32Array( newPositions ),\n      positions.itemSize,\n      positions.normalized\n    );\n\n    const result = new BufferGeometry();\n    result.setAttribute( 'position', positionAttribute );\n    result.setIndex( newIndices );\n\n    return result;\n\n  }\n}\n\nexport { Utils };\n","// javascript-astar\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a binary heap.\n\nclass BinaryHeap {\n  constructor (scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop () {\n    // Store the first element so we can return it later.\n    const result = this.content[0];\n    // Get the element at the end of the array.\n    const end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove (node) {\n    const i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    const end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size () {\n    return this.content.length;\n  }\n\n  rescoreElement (node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown (n) {\n    // Fetch the element that has to be sunk.\n    const element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = ((n + 1) >> 1) - 1;\n      const parent = this.content[parentN];\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        // Swap the elements if the parent is greater.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to sink any further.\n        break;\n      }\n    }\n  }\n\n  bubbleUp (n) {\n    // Look up the target element and its score.\n    const length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      let swap = null;\n      let child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n\n}\n\nexport { BinaryHeap };\n","import { BinaryHeap } from './BinaryHeap';\nimport { Utils } from './Utils.js';\n\nclass AStar {\n  static init (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      //for(var x in graph) {\n      const node = graph[x];\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.cost = 1.0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n    }\n  }\n\n  static cleanUp (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      const node = graph[x];\n      delete node.f;\n      delete node.g;\n      delete node.h;\n      delete node.cost;\n      delete node.visited;\n      delete node.closed;\n      delete node.parent;\n    }\n  }\n\n  static heap () {\n    return new BinaryHeap(function (node) {\n      return node.f;\n    });\n  }\n\n  static search (graph, start, end) {\n    this.init(graph);\n    //heuristic = heuristic || astar.manhattan;\n\n\n    const openHeap = this.heap();\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      const currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        let curr = currentNode;\n        const ret = [];\n        while (curr.parent) {\n          ret.push(curr);\n          curr = curr.parent;\n        }\n        this.cleanUp(ret);\n        return ret.reverse();\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\n      currentNode.closed = true;\n\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\n      const neighbours = this.neighbours(graph, currentNode);\n\n      for (let i = 0, il = neighbours.length; i < il; i++) {\n        const neighbour = neighbours[i];\n\n        if (neighbour.closed) {\n          // Not a valid node to process, skip to next neighbour.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\n        const gScore = currentNode.g + neighbour.cost;\n        const beenVisited = neighbour.visited;\n\n        if (!beenVisited || gScore < neighbour.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbour.visited = true;\n          neighbour.parent = currentNode;\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\n          neighbour.g = gScore;\n          neighbour.f = neighbour.g + neighbour.h;\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbour);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbour);\n          }\n        }\n      }\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  }\n\n  static heuristic (pos1, pos2) {\n    return Utils.distanceToSquared(pos1, pos2);\n  }\n\n  static neighbours (graph, node) {\n    const ret = [];\n\n    for (let e = 0; e < node.neighbours.length; e++) {\n      ret.push(graph[node.neighbours[e]]);\n    }\n\n    return ret;\n  }\n}\n\nexport { AStar };\n","import { Vector3 } from 'three';\n\nimport { Utils } from './Utils';\n\nclass Builder {\n  /**\n   * Constructs groups from the given navigation mesh.\n   * @param  {BufferGeometry} geometry\n   * @param  {number} tolerance\n   * @return {Zone}\n   */\n  static buildZone (geometry, tolerance) {\n\n    const navMesh = this._buildNavigationMesh(geometry, tolerance);\n\n    const zone = {};\n\n    navMesh.vertices.forEach((v) => {\n      v.x = Utils.roundNumber(v.x, 2);\n      v.y = Utils.roundNumber(v.y, 2);\n      v.z = Utils.roundNumber(v.z, 2);\n    });\n\n    zone.vertices = navMesh.vertices;\n\n    const groups = this._buildPolygonGroups(navMesh);\n\n    // TODO: This block represents a large portion of navigation mesh construction time\n    // and could probably be optimized. For example, construct portals while\n    // determining the neighbor graph.\n    zone.groups = new Array(groups.length);\n    groups.forEach((group, groupIndex) => {\n\n      const indexByPolygon = new Map(); // { polygon: index in group }\n      group.forEach((poly, polyIndex) => { indexByPolygon.set(poly, polyIndex); });\n\n      const newGroup = new Array(group.length);\n      group.forEach((poly, polyIndex) => {\n\n        const neighbourIndices = [];\n        poly.neighbours.forEach((n) => neighbourIndices.push(indexByPolygon.get(n)));\n\n        // Build a portal list to each neighbour\n        const portals = [];\n        poly.neighbours.forEach((n) => portals.push(this._getSharedVerticesInOrder(poly, n)));\n\n        const centroid = new Vector3( 0, 0, 0 );\n        centroid.add( zone.vertices[ poly.vertexIds[0] ] );\n        centroid.add( zone.vertices[ poly.vertexIds[1] ] );\n        centroid.add( zone.vertices[ poly.vertexIds[2] ] );\n        centroid.divideScalar( 3 );\n        centroid.x = Utils.roundNumber(centroid.x, 2);\n        centroid.y = Utils.roundNumber(centroid.y, 2);\n        centroid.z = Utils.roundNumber(centroid.z, 2);\n\n        newGroup[polyIndex] = {\n          id: polyIndex,\n          neighbours: neighbourIndices,\n          vertexIds: poly.vertexIds,\n          centroid: centroid,\n          portals: portals\n        };\n      });\n\n      zone.groups[groupIndex] = newGroup;\n    });\n\n    return zone;\n  }\n\n  /**\n   * Constructs a navigation mesh from the given geometry.\n   * @param {BufferGeometry} geometry\n   * @return {Object}\n   */\n  static _buildNavigationMesh (geometry, tolerance) {\n    geometry = Utils.mergeVertices(geometry, tolerance);\n    return this._buildPolygonsFromGeometry(geometry);\n  }\n\n  /**\n   * Spreads the group ID of the given polygon to all connected polygons\n   * @param {Object} seed\n   */\n  static _spreadGroupId (seed) {\n    let nextBatch = new Set([seed]);\n\n    while(nextBatch.size > 0) {\n      const batch = nextBatch;\n      nextBatch = new Set();\n\n      batch.forEach((polygon) => {\n        polygon.group = seed.group;\n        polygon.neighbours.forEach((neighbour) => {\n          if(neighbour.group === undefined) {\n            nextBatch.add(neighbour);\n          }\n        });\n      });\n    }\n  }\n\n  static _buildPolygonGroups (navigationMesh) {\n\n    const polygons = navigationMesh.polygons;\n\n    const polygonGroups = [];\n\n    polygons.forEach((polygon) => {\n      if (polygon.group !== undefined) {\n        // this polygon is already part of a group\n        polygonGroups[polygon.group].push(polygon);\n      } else {\n        // we need to make a new group and spread its ID to neighbors\n        polygon.group = polygonGroups.length;\n        this._spreadGroupId(polygon);\n        polygonGroups.push([polygon]);\n      }\n    });\n\n    return polygonGroups;\n  }\n\n  static _buildPolygonNeighbours (polygon, vertexPolygonMap) {\n    const neighbours = new Set();\n\n    const groupA = vertexPolygonMap[polygon.vertexIds[0]];\n    const groupB = vertexPolygonMap[polygon.vertexIds[1]];\n    const groupC = vertexPolygonMap[polygon.vertexIds[2]];\n\n    // It's only necessary to iterate groups A and B. Polygons contained only\n    // in group C cannot share a >1 vertex with this polygon.\n    // IMPORTANT: Bublé cannot compile for-of loops.\n    groupA.forEach((candidate) => {\n      if (candidate === polygon) return;\n      if (groupB.includes(candidate) || groupC.includes(candidate)) {\n        neighbours.add(candidate);\n      }\n    });\n    groupB.forEach((candidate) => {\n      if (candidate === polygon) return;\n      if (groupC.includes(candidate)) {\n        neighbours.add(candidate);\n      }\n    });\n\n    return neighbours;\n  }\n\n  static _buildPolygonsFromGeometry (geometry) {\n\n    const polygons = [];\n    const vertices = [];\n\n    const position = geometry.attributes.position;\n    const index = geometry.index;\n\n    // Constructing the neighbor graph brute force is O(n²). To avoid that,\n    // create a map from vertices to the polygons that contain them, and use it\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\n    // is related to connectivity of the mesh.\n\n    /** Array of polygon objects by vertex index. */\n    const vertexPolygonMap = [];\n\n    for (let i = 0; i < position.count; i++) {\n      vertices.push(new Vector3().fromBufferAttribute(position, i));\n      vertexPolygonMap[i] = [];\n    }\n\n    // Convert the faces into a custom format that supports more than 3 vertices\n    for (let i = 0; i < geometry.index.count; i += 3) {\n      const a = index.getX(i);\n      const b = index.getX(i + 1);\n      const c = index.getX(i + 2);\n      const poly = {vertexIds: [a, b, c], neighbours: null};\n      polygons.push(poly);\n      vertexPolygonMap[a].push(poly);\n      vertexPolygonMap[b].push(poly);\n      vertexPolygonMap[c].push(poly);\n    }\n\n    // Build a list of adjacent polygons\n    polygons.forEach((polygon) => {\n      polygon.neighbours = this._buildPolygonNeighbours(polygon, vertexPolygonMap);\n    });\n\n    return {\n      polygons: polygons,\n      vertices: vertices\n    };\n  }\n\n  static _getSharedVerticesInOrder (a, b) {\n\n    const aList = a.vertexIds;\n    const a0 = aList[0], a1 = aList[1], a2 = aList[2];\n\n    const bList = b.vertexIds;\n    const shared0 = bList.includes(a0);\n    const shared1 = bList.includes(a1);\n    const shared2 = bList.includes(a2);\n\n    // it seems that we shouldn't have an a and b with <2 shared vertices here unless there's a bug\n    // in the neighbor identification code, or perhaps a malformed input geometry; 3 shared vertices\n    // is a kind of embarrassing but possible geometry we should handle\n    if (shared0 && shared1 && shared2) {\n      return Array.from(aList);\n    } else if (shared0 && shared1) {\n      return [a0, a1];\n    } else if (shared1 && shared2) {\n      return [a1, a2];\n    } else if (shared0 && shared2) {\n      return [a2, a0]; // this ordering will affect the string pull algorithm later, not clear if significant\n    } else {\n      console.warn(\"Error processing navigation mesh neighbors; neighbors with <2 shared vertices found.\");\n      return [];\n    }\n  }\n}\n\nexport { Builder };\n","import { Utils } from './Utils';\n\nclass Channel {\n  constructor () {\n    this.portals = [];\n  }\n\n  push (p1, p2) {\n    if (p2 === undefined) p2 = p1;\n    this.portals.push({\n      left: p1,\n      right: p2\n    });\n  }\n\n  stringPull () {\n    const portals = this.portals;\n    const pts = [];\n    // Init scan state\n    let portalApex, portalLeft, portalRight;\n    let apexIndex = 0,\n      leftIndex = 0,\n      rightIndex = 0;\n\n    portalApex = portals[0].left;\n    portalLeft = portals[0].left;\n    portalRight = portals[0].right;\n\n    // Add start point.\n    pts.push(portalApex);\n\n    for (let i = 1; i < portals.length; i++) {\n      const left = portals[i].left;\n      const right = portals[i].right;\n\n      // Update right vertex.\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\n          // Tighten the funnel.\n          portalRight = right;\n          rightIndex = i;\n        } else {\n          // Right over left, insert left to path and restart scan from portal left point.\n          pts.push(portalLeft);\n          // Make current left the new apex.\n          portalApex = portalLeft;\n          apexIndex = leftIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n\n      // Update left vertex.\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\n          // Tighten the funnel.\n          portalLeft = left;\n          leftIndex = i;\n        } else {\n          // Left over right, insert right to path and restart scan from portal right point.\n          pts.push(portalRight);\n          // Make current right the new apex.\n          portalApex = portalRight;\n          apexIndex = rightIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n    }\n\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\n      // Append last point to path.\n      pts.push(portals[portals.length - 1].left);\n    }\n\n    this.path = pts;\n    return pts;\n  }\n}\n\nexport { Channel };\n","import {\n  BoxBufferGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  Line,\n  LineBasicMaterial,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  SphereBufferGeometry,\n  Vector3,\n} from 'three';\n\nconst colors = {\n  PLAYER: new Color( 0xee836f ).convertGammaToLinear( 2.2 ).getHex(),\n  TARGET: new Color( 0xdccb18 ).convertGammaToLinear( 2.2 ).getHex(),\n  PATH: new Color( 0x00a3af ).convertGammaToLinear( 2.2 ).getHex(),\n  WAYPOINT: new Color( 0x00a3af ).convertGammaToLinear( 2.2 ).getHex(),\n  CLAMPED_STEP: new Color( 0xdcd3b2 ).convertGammaToLinear( 2.2 ).getHex(),\n  CLOSEST_NODE: new Color( 0x43676b ).convertGammaToLinear( 2.2 ).getHex(),\n};\n\nconst OFFSET = 0.2;\n\n/**\n * Helper for debugging pathfinding behavior.\n */\nclass PathfindingHelper extends Object3D {\n  constructor () {\n    super();\n\n    this._playerMarker = new Mesh(\n      new SphereBufferGeometry( 0.25, 32, 32 ),\n      new MeshBasicMaterial( { color: colors.PLAYER } )\n    );\n\n    this._targetMarker = new Mesh(\n      new BoxBufferGeometry( 0.3, 0.3, 0.3 ),\n      new MeshBasicMaterial( { color: colors.TARGET } )\n    );\n\n\n    this._nodeMarker = new Mesh(\n      new BoxBufferGeometry( 0.1, 0.8, 0.1 ),\n      new MeshBasicMaterial( { color: colors.CLOSEST_NODE } )\n    );\n\n\n    this._stepMarker = new Mesh(\n      new BoxBufferGeometry( 0.1, 1, 0.1 ),\n      new MeshBasicMaterial( { color: colors.CLAMPED_STEP } )\n    );\n\n    this._pathMarker = new Object3D();\n\n    this._pathLineMaterial = new LineBasicMaterial( { color: colors.PATH, linewidth: 2 } ) ;\n    this._pathPointMaterial = new MeshBasicMaterial( { color: colors.WAYPOINT } );\n    this._pathPointGeometry = new SphereBufferGeometry( 0.08 );\n\n    this._markers = [\n      this._playerMarker,\n      this._targetMarker,\n      this._nodeMarker,\n      this._stepMarker,\n      this._pathMarker,\n    ];\n\n    this._markers.forEach( ( marker ) => {\n\n      marker.visible = false;\n\n      this.add( marker );\n\n    } );\n\n  }\n\n  /**\n   * @param {Array<Vector3>} path\n   * @return {this}\n   */\n  setPath ( path ) {\n\n    while ( this._pathMarker.children.length ) {\n\n      this._pathMarker.children[ 0 ].visible = false;\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\n\n    }\n\n    path = [ this._playerMarker.position ].concat( path );\n\n    // Draw debug lines\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(path.length * 3), 3));\n    for (let i = 0; i < path.length; i++) {\n      geometry.attributes.position.setXYZ(i, path[ i ].x, path[ i ].y + OFFSET, path[ i ].z);\n    }\n    this._pathMarker.add( new Line( geometry, this._pathLineMaterial ) );\n\n    for ( let i = 0; i < path.length - 1; i++ ) {\n\n      const node = new Mesh( this._pathPointGeometry, this._pathPointMaterial );\n      node.position.copy( path[ i ] );\n      node.position.y += OFFSET;\n      this._pathMarker.add( node );\n\n    }\n\n    this._pathMarker.visible = true;\n\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setPlayerPosition( position ) {\n\n    this._playerMarker.position.copy( position );\n    this._playerMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setTargetPosition( position ) {\n\n    this._targetMarker.position.copy( position );\n    this._targetMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setNodePosition( position ) {\n\n    this._nodeMarker.position.copy( position );\n    this._nodeMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setStepPosition( position ) {\n\n    this._stepMarker.position.copy( position );\n    this._stepMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * Hides all markers.\n   * @return {this}\n   */\n  reset () {\n\n    while ( this._pathMarker.children.length ) {\n\n      this._pathMarker.children[ 0 ].visible = false;\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\n\n    }\n\n    this._markers.forEach( ( marker ) => {\n\n      marker.visible = false;\n\n    } );\n\n    return this;\n\n  }\n\n}\n\nexport { PathfindingHelper };\n"],"names":["plane","Utils","roundNumber","value","decimals","factor","Math","pow","round","sample","list","floor","random","length","distanceToSquared","a","b","dx","x","dy","y","dz","z","isPointInPoly","poly","pt","c","i","l","j","isVectorInPolygon","vector","polygon","vertices","lowestPoint","highestPoint","polygonVertices","vertexIds","forEach","vId","min","max","push","this","triarea2","vequal","mergeVertices","geometry","tolerance","Number","EPSILON","hashToIndex","indices","getIndex","positions","getAttribute","vertexCount","count","nextIndex","newIndices","newPositions","decimalShift","log10","shiftMultiplier","index","getX","hash","getY","getZ","positionAttribute","BufferAttribute","Float32Array","itemSize","normalized","result","BufferGeometry","setAttribute","setIndex","BinaryHeap","scoreFunction","content","element","sinkDown","pop","end","bubbleUp","remove","node","indexOf","size","rescoreElement","n","parentN","parent","elemScore","child2N","child1N","swap","child1Score","AStar","init","graph","f","g","h","cost","visited","closed","cleanUp","heap","search","start","openHeap","currentNode","curr","ret","reverse","neighbours","il","neighbour","gScore","beenVisited","centroid","Error","heuristic","pos1","pos2","e","Builder","buildZone","navMesh","_buildNavigationMesh","zone","v","groups","_buildPolygonGroups","Array","group","groupIndex","indexByPolygon","Map","polyIndex","set","newGroup","neighbourIndices","get","portals","_this","_getSharedVerticesInOrder","Vector3","add","divideScalar","id","_buildPolygonsFromGeometry","_spreadGroupId","seed","nextBatch","Set","batch","undefined","navigationMesh","polygonGroups","polygons","_this2","_buildPolygonNeighbours","vertexPolygonMap","groupB","groupC","candidate","includes","position","attributes","fromBufferAttribute","_this3","aList","a0","a1","a2","bList","shared0","shared1","shared2","from","console","warn","Channel","p1","p2","left","right","stringPull","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","path","Pathfinding","zones","createZone","setZoneData","zoneID","getRandomNode","groupID","nearPosition","nearRange","candidates","p","getClosestNode","checkPolygon","closestNode","closestDistance","Infinity","distance","findPath","startPosition","targetPosition","nodes","farthestNode","paths","getPortalFromTo","channel","nextPolygon","map","shift","prototype","getGroup","Plane","closestNodeGroup","setFromCoplanarPoints","abs","distanceToPoint","measuredDistance","clampStep","point","triangle","Triangle","endPoint","closestPoint","startRef","endRef","endTarget","nodeQueue","nodeDepth","projectPoint","copy","closestPointToPoint","depth","colors","PLAYER","Color","convertGammaToLinear","getHex","TARGET","PATH","WAYPOINT","CLAMPED_STEP","CLOSEST_NODE","PathfindingHelper","_playerMarker","Mesh","SphereBufferGeometry","MeshBasicMaterial","color","_targetMarker","BoxBufferGeometry","_nodeMarker","_stepMarker","_pathMarker","Object3D","_pathLineMaterial","LineBasicMaterial","linewidth","_pathPointMaterial","_pathPointGeometry","_markers","marker","visible","setPath","children","concat","setXYZ","Line","setPlayerPosition","setTargetPosition","setNodePosition","setStepPosition","reset"],"mappings":"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"}